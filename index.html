<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Pulley Scene – Pure HTML + Three.js</title>
  <style>
    body {
      margin: 0;
      background: #f7f7f7;
      overflow: hidden;
    }
    #container {
      width: 100vw;
      height: 100vh;
    }
  </style>
  
  <!-- Add import maps to handle bare module specifiers -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.module.js",
      "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.155.0/examples/jsm/"
    }
  }
  </script>
</head>

<body>
  <div id="container"></div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

    const container = document.getElementById("container");

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf7f7f7);

    const camera = new THREE.PerspectiveCamera(40, 2, 0.1, 1000);
    camera.position.set(0, 40, 100);

    /* LIGHTS */
    const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
    hemi.position.set(0, 50, 0);
    scene.add(hemi);

    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(40, 50, 30);
    scene.add(dir);

    /* DIAMOND TEXTURE FOR ROLLER */
   /* TILEABLE DIAMOND TEXTURE FOR ROLLER */
function createDiamondTexture() {
  const size = 256;
  const spacing = 32;            // perfect tile spacing
  const cvs = document.createElement("canvas");
  cvs.width = cvs.height = size;
  const ctx = cvs.getContext("2d");

  ctx.fillStyle = "#333";
  ctx.fillRect(0, 0, size, size);

  ctx.strokeStyle = "#111";
  ctx.lineWidth = 3;

  // Draw 45° diagonal lines (bottom-left → top-right)
  for (let x = -size; x < size * 2; x += spacing) {
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x + size, size);
    ctx.stroke();
  }

  // Draw -45° diagonal lines (top-left → bottom-right)
  for (let x = -size; x < size * 2; x += spacing) {
    ctx.beginPath();
    ctx.moveTo(x, size);
    ctx.lineTo(x + size, 0);
    ctx.stroke();
  }

  const tex = new THREE.CanvasTexture(cvs);
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;

  // PERFECT REPEAT — no mismatch
  tex.repeat.set(5.0, 1.35);

  // rotate to match cylinder orientation
  tex.center.set(0.5, 0.5);
  tex.rotation = Math.PI / 2;

  return tex;
}


    const bodyTexture = createDiamondTexture();
    const rollerRadius = 30;
    const rollerLength = 130;

    /* ROLLER BODY */
    const bodyGeom = new THREE.CylinderGeometry(rollerRadius, rollerRadius, rollerLength, 64);
    bodyGeom.rotateZ(Math.PI / 2);

    const bodyMat = new THREE.MeshStandardMaterial({
      map: bodyTexture,
      metalness: 0.2,
      roughness: 0.6
    });

    const body = new THREE.Mesh(bodyGeom, bodyMat);
    scene.add(body);

    /* SHAFT */
    const shaftGeom = new THREE.CylinderGeometry(5, 5, 180, 32);
    const shaftMat = new THREE.MeshStandardMaterial({
      color: 0x7e684a,
      metalness: 0.3,
      roughness: 0.9
    });

    const shaft = new THREE.Mesh(shaftGeom, shaftMat);
    shaft.rotateZ(Math.PI / 2);
    scene.add(shaft);

    /* BORE HOLES */
    const boreGeom = new THREE.CylinderGeometry(0.5, 0.5, 0.5, 32);
    const boreMat = new THREE.MeshStandardMaterial({
      color: 0x2a2a2a,
      metalness: 0.1,
      roughness: 0.2
    });

    const boreFront = new THREE.Mesh(boreGeom, boreMat);
    boreFront.rotateZ(Math.PI / 2);
    boreFront.position.x = 180 / 2 + 0.1;
    scene.add(boreFront);

    const boreBack = new THREE.Mesh(boreGeom, boreMat);
    boreBack.rotateZ(Math.PI / 2);
    boreBack.position.x = -(180 / 2 + 0.1);
    scene.add(boreBack);

    /* CAP TEMPLATE */
    const capGroup = new THREE.Group();
    const capColor = 0x1f66d0;

    const capOuter = new THREE.CylinderGeometry(rollerRadius * 1.05, rollerRadius * 1.05, 8, 64);
    const capMat = new THREE.MeshStandardMaterial({
      color: capColor,
      metalness: 0.3,
      roughness: 0.4
    });

    const capMesh = new THREE.Mesh(capOuter, capMat);
    capMesh.rotateZ(Math.PI / 2);
    capGroup.add(capMesh);

    /* RECESSED HUBS */
    const hubGeom = new THREE.CylinderGeometry(10, 10, 7, 64);
    const hubMat = new THREE.MeshStandardMaterial({
      color: 0x0b2350,
      metalness: 0.2,
      roughness: 0.9
    });

    function hub(offset) {
      const h = new THREE.Mesh(hubGeom, hubMat);
      h.rotateZ(Math.PI / 2);
      h.position.x = offset;
      return h;
    }

    capGroup.add(hub(2.4), hub(-2.4));

    /* BOLTS */
    const boltGeom = new THREE.CylinderGeometry(0.9, 0.9, 4, 10);
    const boltMat = new THREE.MeshStandardMaterial({
      color: 0xc0c0c0,
      metalness: 0.9,
      roughness: 0.25
    });

    const boltCount = 12;
    const boltCircleRadius = 7.2;

    for (let i = 0; i < boltCount; i++) {
      const angle = (i / boltCount) * Math.PI * 2;

      const y = Math.sin(angle) * boltCircleRadius;
      const z = Math.cos(angle) * boltCircleRadius;

      const b1 = new THREE.Mesh(boltGeom, boltMat);
      b1.rotation.z = Math.PI / 2;
      b1.position.set(5, y, z);

      const b2 = b1.clone();
      b2.position.x = -5;

      capGroup.add(b1, b2);
    }

    /* SENSOR MODULES */
    function addModulesToCap(targetCap, flip) {
      const sizes = [
        [13, 3, 29.8],
        [13, 29.8, 3],
        [13, 3, 29.8],
        [13, 29.8, 3]
      ];

      const moduleRadius = 14;
      const n = sizes.length;

      for (let i = 0; i < n; i++) {
        const [w, h, d] = sizes[i];
        const geom = new THREE.BoxGeometry(w, h, d);
        const mat = new THREE.MeshStandardMaterial({
          color: 0x1f66d0,
          metalness: 0.2,
          roughness: 0.45
        });

        const mod = new THREE.Mesh(geom, mat);
        const angle = (i / n) * Math.PI * 2;

        mod.position.set(
          flip ? -2 : 2,
          Math.sin(angle) * moduleRadius,
          Math.cos(angle) * moduleRadius
        );

        if (flip) mod.rotation.y = Math.PI;
        targetCap.add(mod);
      }
    }

    /* BASE DISCS */
    const baseDiscGeom = new THREE.CylinderGeometry(rollerRadius * 0.95, rollerRadius * 0.95, 3, 30);
    const baseDiscMat = new THREE.MeshStandardMaterial({
      color: 0x1f66d0,
      metalness: 0.3,
      roughness: 0.45
    });

    const baseDisc = new THREE.Mesh(baseDiscGeom, baseDiscMat);
    baseDisc.rotateZ(Math.PI / 2);

    const baseDiscFront = baseDisc.clone();
    baseDiscFront.position.x = 2.8;

    const baseDiscBack = baseDisc.clone();
    baseDiscBack.position.x = -2.8;

    capGroup.add(baseDiscFront, baseDiscBack);

    /* FINAL FRONT + BACK CAPS */
    const cap1 = capGroup.clone();
    cap1.position.x = -rollerLength / 2 - 3;
    addModulesToCap(cap1, false);

    const cap2 = capGroup.clone();
    cap2.position.x = rollerLength / 2 + 3;
    addModulesToCap(cap2, true);

    scene.add(cap1, cap2);

    /* CONTROLS */
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    function onResize() {
      renderer.setSize(container.clientWidth, container.clientHeight);
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
    }

    window.addEventListener("resize", onResize);
    onResize();

    /* ANIMATION LOOP */
    function animate() {
      body.rotation.x += 0.003;
      shaft.rotation.x += 0.003;

      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();
  </script>
</body>
</html>